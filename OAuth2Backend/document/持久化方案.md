# OAuth2 Plugin 持久化层设计方案

## 目标

将当前基于内存的 OAuth2 存储重构为数据库持久化存储，同时保持接口不变，支持未来切换不同存储后端 (PostgreSQL/MySQL/Redis)。

---

## 1. 数据库 Schema 设计 (PostgreSQL)

### 1.1 `oauth2_clients` 表

存储已注册的 OAuth2 客户端应用信息。

```sql
CREATE TABLE oauth2_clients (
    client_id       VARCHAR(64) PRIMARY KEY,
    client_secret   VARCHAR(128) NOT NULL,
    redirect_uris   TEXT NOT NULL,
    allowed_scopes  TEXT,
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 1.2 `oauth2_authorization_codes` 表

存储短期有效的授权码。

```sql
CREATE TABLE oauth2_authorization_codes (
    code            VARCHAR(64) PRIMARY KEY,
    client_id       VARCHAR(64) NOT NULL REFERENCES oauth2_clients(client_id),
    user_id         VARCHAR(128) NOT NULL,
    scope           TEXT,
    redirect_uri    TEXT NOT NULL,
    code_challenge  VARCHAR(128),
    code_challenge_method VARCHAR(10),
    expires_at      TIMESTAMP NOT NULL,
    used            BOOLEAN DEFAULT FALSE,
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX idx_auth_codes_expires ON oauth2_authorization_codes(expires_at);
```

### 1.3 `oauth2_access_tokens` 表

存储已颁发的 Access Token。

```sql
CREATE TABLE oauth2_access_tokens (
    token           VARCHAR(128) PRIMARY KEY,
    client_id       VARCHAR(64) NOT NULL REFERENCES oauth2_clients(client_id),
    user_id         VARCHAR(128) NOT NULL,
    scope           TEXT,
    expires_at      TIMESTAMP NOT NULL,
    revoked         BOOLEAN DEFAULT FALSE,
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX idx_access_tokens_user ON oauth2_access_tokens(user_id);
CREATE INDEX idx_access_tokens_expires ON oauth2_access_tokens(expires_at);
```

### 1.4 `oauth2_refresh_tokens` 表 (新增功能)

支持长期会话维持。

```sql
CREATE TABLE oauth2_refresh_tokens (
    token           VARCHAR(128) PRIMARY KEY,
    access_token    VARCHAR(128) NOT NULL REFERENCES oauth2_access_tokens(token),
    client_id       VARCHAR(64) NOT NULL,
    user_id         VARCHAR(128) NOT NULL,
    scope           TEXT,
    expires_at      TIMESTAMP NOT NULL,
    revoked         BOOLEAN DEFAULT FALSE,
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

---

## 2. Redis Schema 设计 (Redis)

利用 Redis 的 Key-Value 和 TTL 特性实现高性能存储。

### 2.1 Key 命名规范

| 实体 | Key Pattern | 类型 | TTL | 说明 |
|------|-------------|------|-----|------|
| Client | `oauth2:client:{client_id}` | Hash | 无 | 字段: secret, redirect_uris, scopes |
| Auth Code | `oauth2:code:{code}` | String | 10分 | Value: JSON 序列化的 Code 对象 |
| Access Token | `oauth2:token:{token}` | String | 1小时 | Value: JSON 序列化的 Token 对象 |
| Refresh Token | `oauth2:refresh:{token}` | String | 30天 | Value: JSON 序列化的 Refresh Token 对象 |

### 2.2 数据结构示例 (JSON Value)

**Auth Code Value:**

```json
{
  "client_id": "vue-client",
  "user_id": "admin",
  "scope": "openid profile",
  "redirect_uri": "http://...",
  "expires_at": 1735689000,
  "used": false
}
```

**Access Token Value:**

```json
{
  "client_id": "vue-client",
  "user_id": "admin",
  "scope": "openid profile",
  "expires_at": 1735693000,
  "revoked": false
}
```

### 2.3 实现细节与注意事项

1. **同步调用保证稳定性**：
    由于 Drogon 的 `execCommandAsync` 在处理临时字符串对象（如 `std::string::c_str()`）时存在潜在的生命周期问题（Use-After-Free），导致后端并发崩溃。因此，所有写入与删除操作（`saveAuthCode`, `saveAccessToken`, `revoke*` 等）目前采用 **同步调用 (`execCommandSync`)** 实现，以确保参数在命令执行期间保持有效。未来优化可考虑深拷贝或更安全的异步 API。

2. **Client 验证逻辑**：
    在 `/authorize` 阶段，协议通常不传递 `client_secret`。因此 `validateClient` 方法调整为：当传入的 `clientSecret` 为空时，仅验证 Client ID 是否存在；仅在 `/token` 阶段（传入了 secret）才进行哈希比对。

---

## 3. 存储抽象接口设计 (IOAuth2Storage)

引入 **Strategy Pattern** 支持多种存储后端。

### 3.1 接口定义

```cpp
class IOAuth2Storage {
public:
    virtual ~IOAuth2Storage() = default;
    virtual std::optional<OAuth2Client> getClient(const std::string& clientId) = 0;
    virtual void saveAuthCode(const OAuth2AuthCode& code) = 0;
    virtual std::optional<OAuth2AuthCode> getAuthCode(const std::string& code) = 0;
    virtual void markAuthCodeUsed(const std::string& code) = 0;
    virtual void saveAccessToken(const OAuth2AccessToken& token) = 0;
    virtual std::optional<OAuth2AccessToken> getAccessToken(const std::string& token) = 0;
    virtual void revokeAccessToken(const std::string& token) = 0;
};
```
